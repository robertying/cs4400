<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0046)https://pubweb.eng.utah.edu/~cs4400/shell.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=0.8"><title>Shell Assignment</title><link rel="stylesheet" type="text/css" href="./Shell Assignment_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="./Shell Assignment_files/racket.css" title="default"><link rel="stylesheet" type="text/css" href="./Shell Assignment_files/manual-style.css" title="default"><style type="text/css">
.tocset { background-color: hsl(87.5, 24%, 52.5%); }
</style><link rel="stylesheet" type="text/css" href="./Shell Assignment_files/manual-racket.css" title="default"><script type="text/javascript" src="./Shell Assignment_files/scribble-common.js"></script><script type="text/javascript" src="./Shell Assignment_files/manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a></td><td></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html" class="tocviewlink" data-pltdoc="x">CS 4400 – Computer Systems &nbsp; Fall 2018</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._.Schedule__subject_to_change_%29" class="tocviewlink" data-pltdoc="x">Schedule <span class="Smaller">[subject to change]</span></a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._staff%29" class="tocviewlink" data-pltdoc="x">Course Staff</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._desc%29" class="tocviewlink" data-pltdoc="x">Course Description</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._.Videos%29" class="tocviewlink" data-pltdoc="x">Videos</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._.No_.Videos%29" class="tocviewlink" data-pltdoc="x">No Videos</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" class="tocviewselflink" data-pltdoc="x">Homework Assignments</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a></td><td></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" class="tocviewlink" data-pltdoc="x">Homework Assignments</a></td></tr></tbody></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/bomb.html" class="tocviewlink" data-pltdoc="x">Bomb Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/performance.html" class="tocviewlink" data-pltdoc="x">Performance Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html" class="tocviewlink" data-pltdoc="x">Linking Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html" class="tocviewselflink" data-pltdoc="x">Shell Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/malloc.html" class="tocviewlink" data-pltdoc="x">Malloc Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/servlab.html" class="tocviewlink" data-pltdoc="x">Server Assignment</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a></td><td></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html" class="tocviewselflink" data-pltdoc="x">Shell Assignment</a></td></tr></tbody></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.The_.Hot-or-.Cold_.Game%29" class="tocviewlink" data-pltdoc="x">The Hot-<wbr>or-<wbr>Cold Game</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Game_.Protocol%29" class="tocviewlink" data-pltdoc="x">Game Protocol</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Running_a_.Tournament%29" class="tocviewlink" data-pltdoc="x">Running a Tournament</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Implementation%29" class="tocviewlink" data-pltdoc="x">Implementation</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Examples_and_.Tests%29" class="tocviewlink" data-pltdoc="x">Examples and Tests</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._shlab-evaluation%29" class="tocviewlink" data-pltdoc="x">Evaluation</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._shlab-tips%29" class="tocviewlink" data-pltdoc="x">Tips</a></td></tr></tbody></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tbody><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.The_.Hot-or-.Cold_.Game%29" class="tocsubseclink" data-pltdoc="x">The Hot-<wbr>or-<wbr>Cold Game</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Game_.Protocol%29" class="tocsubseclink" data-pltdoc="x">Game Protocol</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Running_a_.Tournament%29" class="tocsubseclink" data-pltdoc="x">Running a Tournament</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Implementation%29" class="tocsubseclink" data-pltdoc="x">Implementation</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._.Examples_and_.Tests%29" class="tocsubseclink" data-pltdoc="x">Examples and Tests</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._shlab-evaluation%29" class="tocsubseclink" data-pltdoc="x">Evaluation</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html#%28part._shlab-tips%29" class="tocsubseclink" data-pltdoc="x">Tips</a></td></tr></tbody></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html" title="backward to &quot;Linking Assignment&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" title="up to &quot;Homework Assignments&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/malloc.html" title="forward to &quot;Malloc Assignment&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div><h4><a name="(part._shell)"></a>Shell Assignment</h4><p>Due: Wednesday, November 7, 11:59pm</p><p>For this assignment, you will write a program to run a tournament for
automated players of a hot-or-cold game. You don’t have to implement
the game itself or the players in the game; those are provided as C
programs. Your task is to write a program that runs those programs,
and that task will involve communicating messages between the
game-maker program to the player programs. It’s not a “shell” in the
usual sense, but your program will be shell-like in the way that it
manages and controls processes.</p><p>Specifically, you will implement a <span class="stt">run_tournament</span> program that
takes at least three arguments: a seed for a random generator (up to 8 digits), a
number of rounds to run (up to 8 digits), and a path to the first player program. Any
number of additional player-program paths can be provided as
additional arguments. For example,</p><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">./run_tournament 42 100 scan_player step_player</span></p><p>will run a tournament with 100 rounds pitting <span class="stt">scan_player</span> against
<span class="stt">step_player</span>. The seed <span class="stt">42</span> determines the “random” starting
positions that are given to each player in each round. As long as the
players always behave the same way for a given starting position, then
running a tournament with a given seed number will produce the same
results. In this case, the output ends with the three lines</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">100</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">1 99 0</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">99 1 0</span></p></td></tr></tbody></table><p></p><p>which means that the first player, <span class="stt">scan_player</span>, won 1 round, lost
99 rounds, and failed in 0 rounds; the second player, <span class="stt">step_player</span>, won
99 rounds, lost 1 round, and failed in 0 rounds.</p><h5><a name="(part._.The_.Hot-or-.Cold_.Game)"></a>The Hot-or-Cold Game</h5><p>Your task is <span style="font-style: italic">not</span> to implement the hot-or-cold game. Since your
tournament program must manage the communication between the game
maker and players, however, it’s helpful to understand how the game
works.</p><p>The hot-or-cold game involves a grid of positions that are addressed
by pairs <span style="font-style: italic"></span>(<span style="font-style: italic">x,y</span>)<span style="font-style: italic"></span> where <span style="font-style: italic">x</span> and <span style="font-style: italic">y</span> range from 0 to 99
inclusive. The game maker chooses a “random” position on the grid as
the target position. It then places each player at a “random” position
that is between 40 and 45 steps away from the target position. A
distance in steps is a Manhattan distance (i.e., the sum of the
magnitude of differences between the respective <span style="font-style: italic">x</span> and <span style="font-style: italic">y</span>
components of a player’s position and the target position).</p><p>On each turn, a player picks a new position by moving any number of
steps in either the <span style="font-style: italic">x</span> or <span style="font-style: italic">y</span> direction (but not both).
That is, the new position must have either the same <span style="font-style: italic">x</span> or
<span style="font-style: italic">y</span> component as its old position, and it cannot be the same as
the old position. The game maker responds with “winner” if the new
position is the target position, “colder” if the new position is
further in steps from the target position, “hotter” if the new
position is closer but not yet the target position, and “steady” if
the new position is the same distance in steps as the old position
(which is possible if the new position is an even number of steps from
the old position). The game maker gives each player a turn, and it
iterates through multiple turns until some player wins.</p><p>If a player makes an invalid move (e.g., by picking a new position
where both the <span style="font-style: italic">x</span> and <span style="font-style: italic">y</span> components are different from the
old position), the game maker responds with “wrong!” and does not
give the player any further moves in the round. If all players go wrong
in this way, a round can end without winner. Otherwise, there is no
limit on the number of turns that are allowed in a round to find a
winner.</p><h5><a name="(part._.Game_.Protocol)"></a>Game Protocol</h5><p>The game maker and the players communicate by reading from standard
input and writing to standard output. The game maker does not know how
to run players or how to communicate to multiple programs; it will be
the job of your <span class="stt">run_tournament</span> program to run the game maker and
players and to relay messages between them.</p><p>All communication with the game maker and players is based on a line
that is exactly 7 bytes, where the seventh byte is always a newline
character. A position line is exactly two decimal digits for the
<span style="font-style: italic">x</span> component, one comma, one space, exactly two decimal digits
for the <span style="font-style: italic">y</span> component, and a newline. A guidance response from
the game maker is exactly either <span class="RktInBG"><span class="hspace"></span><span class="RktIn">winner</span><span class="hspace"></span></span>, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">colder</span><span class="hspace"></span></span>,
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">hotter</span><span class="hspace"></span></span>, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">steady</span><span class="hspace"></span></span>, or <span class="RktInBG"><span class="hspace"></span><span class="RktIn">wrong!</span><span class="hspace"></span></span> followed by a
newline.</p><p>The <span class="stt">game_maker</span> program takes four command-line arguments: a seed
number, a player count (which must be at least 1), a minimum starting
distance, and a maximum starting distance. If the second argument is
<span style="font-style: italic">n</span>, then <span class="stt">game_maker</span> responds immediately with one position
line for the target (which is not meant to be seen by players, of
course) and <span style="font-style: italic">n</span> position lines that are the starting positions of
the players, in order. For example,</p><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">./game_maker 42 2 3 3</span></p><p>starts a two-player round where both are initially 3 steps away from
the target, since both the maximum and minimum distance are 3.
Starting <span class="stt">game_maker</span> that way produces the output</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 40</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">64, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">65, 42</span></p></td></tr></tbody></table><p></p><p>which says that the target is at <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>6<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span>, the first player
starts at <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>4<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>1<span style="font-style: italic"></span>)<span style="font-style: italic"></span>, and the second player starts at <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>5<span style="font-style: italic">,</span><span style="font-style: italic">
</span><span style="font-style: italic"></span>4<span style="font-style: italic"></span>2<span style="font-style: italic"></span>)<span style="font-style: italic"></span>.</p><p>The game maker program then waits for an input line that is the first
player’s new position. For example, given the input</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">63, 41</span></p></td></tr></tbody></table><p></p><p>the server responds with</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">colder</span></p></td></tr></tbody></table><p></p><p>since <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>3<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>1<span style="font-style: italic"></span>)<span style="font-style: italic"></span> is farther from <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>6<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span> than the
player’s previous position <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>4<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>1<span style="font-style: italic"></span>)<span style="font-style: italic"></span>.</p><p>If the input were instead</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">65, 41</span></p></td></tr></tbody></table><p></p><p>then the server would respond with</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">hotter</span></p></td></tr></tbody></table><p></p><p>since <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>5<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>1<span style="font-style: italic"></span>)<span style="font-style: italic"></span> is closer to <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>6<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span> than the player’s
previous position <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>4<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>1<span style="font-style: italic"></span>)<span style="font-style: italic"></span>.</p><p>If the input were</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">65, 42</span></p></td></tr></tbody></table><p></p><p>then the server would respond with</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">wrong!</span></p></td></tr></tbody></table><p></p><p>because <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>5<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>2<span style="font-style: italic"></span>)<span style="font-style: italic"></span> is not a valid move from the previous position
<span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>4<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>1<span style="font-style: italic"></span>)<span style="font-style: italic"></span>.</p><p>After replying for the first player’s move, <span class="stt">game_maker</span> waits for
the second player’s move as an input line, and so on. If
<span class="stt">game_maker</span> responds to a move with <span class="stt">wrong!</span>, then it does not
wait for a move from the player for future turns; that is, it skips
the player for the rest of the round.</p><p>The <span class="stt">game_maker</span> program exits with status 0 as soon as it responds
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">winner</span><span class="hspace"></span></span> to any move. The <span class="stt">game_maker</span> program exits with
status 1 if all players have gone wrong.</p><p>Here’s a complete transcript of a potential run of <span class="stt">game_maker</span>,
where lines with a blue background correspond to input lines for
<span class="stt">game_maker</span> and other lines are <span class="stt">game_maker</span>’s output.</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 40</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">64, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">65, 42</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">65, 41</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">hotter</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">65, 43</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">colder</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">67, 41</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">steady</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">00, 43</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">colder</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">66, 41</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">hotter</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">01, 40</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">wrong!</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">66, 42</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">colder</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">66, 40</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">winner</span></p></td></tr></tbody></table><p></p><p>In this transcript, the second player goes wrong on its third turn by
making an invalid move, so it is skipped for the rest of the round, and
the last two moves are both by the first player (which wins).</p><p>A player program, such as <span class="stt">scan_player</span> or <span class="stt">step_player</span>,
expects an initial input line that is a position line. It responds
with position line for the new location, and then it waits for a
guidance-response line as input—<wbr>iterating position output and
guidance input until the guidance input line is <span class="RktInBG"><span class="hspace"></span><span class="RktIn">winner</span><span class="hspace"></span></span>.</p><p>Here’s a transcript of a potential run of <span class="stt">step_player</span>, where
lines with a blue background correspond to input lines for
<span class="stt">step_player</span>, other lines are <span class="stt">step_player</span>’s output,
and the target turns out to be at <span style="font-style: italic"></span>(<span style="font-style: italic"></span>6<span style="font-style: italic"></span>6<span style="font-style: italic">, </span>4<span style="font-style: italic"></span>0<span style="font-style: italic"></span>)<span style="font-style: italic"></span>.</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span style="background-color: lightblue"><span class="stt">64, 41</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">65, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">hotter</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">hotter</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">67, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">colder</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">hotter</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">65, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">colder</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">hotter</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 42</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">colder</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 41</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">hotter</span></span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">66, 40</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span style="background-color: lightblue"><span class="stt">winner</span></span></p></td></tr></tbody></table><p></p><p>Note that the input to a player corresponds to a subset of the output
of the game maker, and the input to the game maker corresponds to
output from multiple players. The game maker and players cannot talk
directly. Your <span class="stt">run_tournament</span> function will talk to all the other
programs, accepting each output line from the game maker and sending
it to an appropriate player, and accepting each player’s output (at
the appropriate time) and sending it to the game maker.</p><h5><a name="(part._.Running_a_.Tournament)"></a>Running a Tournament</h5><p>Given a seed <span style="font-style: italic">s</span>, a round count <span style="font-style: italic">r</span>, and <span style="font-style: italic">n</span> player
programs, your <span class="stt">run_tournament</span> program should run <span style="font-style: italic">r</span> rounds.
The <span class="stt">run_tournament</span> program should keep track of the number of
times each player wins, loses, and fails; a program will either win or
lose every round, and it may fail on some rounds.</p><p>For each round <span style="font-style: italic">i</span> where <span style="font-style: italic">i</span> ranges from 0 to <span style="font-style: italic">r-</span>1<span style="font-style: italic"></span>,</p><ul><li><p>Run <span class="stt">game_maker</span> with the seed <span style="font-style: italic">s+i</span>, player count
<span style="font-style: italic">n</span>, minimum initial distance <span class="stt">40</span>, and maximum initial
distance <span class="stt">45</span>. By using <span style="font-style: italic">s+i</span> as the seed for the game
maker, the whole tournament is predictable (as long as the
players are predictable), but each round within the tournament
has a different target and starting positions.</p></li><li><p>Run each of the <span style="font-style: italic">n</span> players, keeping them in the order
provided on the command line. Note that the first player will
be first throughout the tournament, but the game is still fair,
because the <span class="stt">game_maker</span> program will start players at
varying distances from the target across rounds.</p></li><li><p>When some player program wins, the round is over. Make sure
that the winning program exits normally with status 0,
otherwise count that round as a failure for the program
(despite also being a win). Force all other player processes to
terminate, and don’t count forced termination by itself as a
failure.</p></li><li><p>When a program makes a bad move, either through output that is
not a valid position line or when the game maker replies with
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">wrong!</span><span class="hspace"></span></span>, count the program as both losing and failing
for that round of the tournament.</p><p>Although it’s possible for a player program to incorrectly
terminate after its most recent move and just before some other
player wins, you do not have to detect that situation and count
it as a failure.</p></li></ul><p>Your <span class="stt">run_tournament</span> program must end with a report of <span style="font-style: italic">n+</span>1<span style="font-style: italic"></span>
lines to standard output. (Other output before the last <span style="font-style: italic">n+</span>1<span style="font-style: italic"></span> lines
is allowed and ignored.) The first output line is the number of rounds
played as a decimal number followed by a newline. Each additional line
reports the results for each program, in the order of the players, as
three decimal numbers: wins, loses, and failures. The three numbers
should have a single space in between, and (obviously) the line must
be terminated by a newline.</p><p>If the <span class="stt">run_tournament</span> program receives a <span class="stt">SIGINT</span> signal
(i.e., it’s interrupted by Ctl-C), then it should finish the current
round and report the results of the truncated tournament (i.e., report
the number of rounds completed and the results for those rounds, then
exit). When <span class="stt">run_tournament</span> is run in a terminal, Ctl-C should not
cause the player programs to fail; that is, the Ctl-C should not reach
the player programs, and they should continue to finish the current
round.</p><p>Your <span class="stt">run_tournament</span> program can assume that the <span class="stt">game_maker</span>
program is in the current directory and always works properly. Your
<span class="stt">run_tournament</span> program can also assume that the given player
programs are valid executables, but they might not function properly;
that is, they may exit unexpectedly, exit in the wrong way, or produce
bad output. As a simplification, however, the player programs will
never become unresponsive without first behaving in some other
detectable bad way, and they will never write to standard error as
long as they are called properly and receive well-formed lines.</p><h5><a name="(part._.Implementation)"></a>Implementation</h5><p>The <a href="https://pubweb.eng.utah.edu/~cs4400/shlab-handout.zip"><span class="stt">shlab-handout.zip</span></a> archive provides an
initial <span class="stt">run_tournament</span> implementation that just parses the
command-line arguments. Your job is to complete the implementation in
<span class="stt">"run_tournament.c"</span>. Within <span class="stt">"run_tournament.c"</span>, you can add
functions, change function signatures, or whatever to implement new
functionality.</p><p>You will handin a single file, <span class="stt">"run_tournament.c"</span>, which must
use only ANSI standard C syntax with GNU extensions (as is the default
for CADE machines), standard C libraries, Linux system libraries, and
the <span class="stt">"csapp.c"</span> wrapper functions.</p><p>You don’t need to modify <span class="stt">"game_maker.c"</span> or any of the player
implementations. You may find it amusing or modestly instructive to
create a better player than <span class="stt">"jump_player.c"</span>, but that’s
beyond the requirements of the assignment.</p><h5><a name="(part._.Examples_and_.Tests)"></a>Examples and Tests</h5><p>The <a href="https://pubweb.eng.utah.edu/~cs4400/shlab-handout.zip"><span class="stt">shlab-handout.zip</span></a> archive includes several
players that you can run in a tournament:</p><ul><li><p><span class="stt">scan_player</span> naively scans every position in the grid.</p></li><li><p><span class="stt">step_player</span> takes one step at a time, abandoning each of
the four possible directions as soon as it gets a
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">colder</span><span class="hspace"></span></span> for that direction. This player will normally
beat <span class="stt">scan_player</span>.</p></li><li><p><span class="stt">jump_player</span> tries to take bigger steps when it’s moving in
the right direction. This player will normally beat all of the
other provided players.</p></li><li><p><span class="stt">fumble_player</span> is a broken variant of <span class="stt">step_player</span>: it
exits in different bad ways just after winning. So,
<span class="stt">fumble_player</span> always ends up with the same number of wins
and failures.</p></li><li><p><span class="stt">garbled_player</span> takes a bad step, after a while, by
outputting a bad position line.</p></li><li><p><span class="stt">distracted_player</span> takes a bad step, after a while, by
outputting a partial position line, closing its output, and
going into an infinite loop.</p></li><li><p><span class="stt">unreliable_player</span> sometimes behaves correctly, sometimes
fumbles a win, and sometimes takes a bad step. Its behavior
depends on the starting position, so the player behaves
deterministically (but differently for different rounds).</p></li></ul><p>The <a href="https://pubweb.eng.utah.edu/~cs4400/shlab-handout.zip"><span class="stt">shlab-handout.zip</span></a> archive archive also
includes a <span class="stt">"test.rkt"</span> script runs <span class="stt">run_tournament</span> with
various combinations of players to check for specific expected
results. Run <span class="stt">"test.rkt"</span> with <span class="stt">racket test.rkt</span> followed
optionally by any of the following flags:</p><ul><li><p><span class="nobreak"><span class="stt">-v</span></span> or <span class="nobreak"><span class="stt">--verbose</span></span> —<wbr> prints information about the tests
being run.</p></li><li><p><span class="nobreak"><span class="stt">--no-fail</span></span> —<wbr> skips tests that involve failing players.</p></li><li><p><span class="nobreak"><span class="stt">--no-ctl-c</span></span> —<wbr> skips tests that check Ctl-C behavior.</p></li><li><p><span class="nobreak"><span class="stt">--stop-on-error</span></span> —<wbr> stop as soon as a test fails.</p></li></ul><p>When all tests pass (other than ones skipped by <span class="nobreak"><span class="stt">--no-fail</span></span> or
<span class="nobreak"><span class="stt">--no-ctl-c</span></span>), the <span class="stt">"test.rkt"</span> script prints “All tests
passed.” The full sets of tests should take only about 10 seconds to
complete.</p><p>A test fails when <span class="stt">run_tournament</span> does not print the expected
output for a tournament. A test also fails anything is printed to
standard error by <span class="stt">run_tournament</span>, the game maker, or one of the
player programs.</p><h5><a name="(part._shlab-evaluation)"></a>Evaluation</h5><p>Grades will be assigned based on a level of completion, where each
level requires success at the lower levels:</p><ul><li><p>up to 80 points: Works with non-failing players, such as
<span class="stt">scan_player</span>, <span class="stt">step_player</span>, and <span class="stt">jump_player</span>.</p><p>This level of completion corresponds to running <span class="stt">"test.rkt"</span>
with the <span class="nobreak"><span class="stt">--no-fail</span></span> and <span class="nobreak"><span class="stt">--no-ctl-c</span></span> flags.</p></li><li><p>up to 90 points: Works for all players, including those that
sometimes fail.</p><p>This level of completion corresponds to running <span class="stt">"test.rkt"</span>
with <span class="nobreak"><span class="stt">--no-ctl-c</span></span> flag.</p></li><li><p>up to 100 points: Works on all players, including those that
sometimes fail, and also implements Ctl-C handling.</p><p>This level of completion corresponds to running <span class="stt">"test.rkt"</span>
with no flags.</p></li></ul><p>Although tests are provided, grading may use additional test players
of similar complexity at each level.</p><h5><a name="(part._shlab-tips)"></a>Tips</h5><ul><li><p>A single pipe only works for one-way communication, so create
two pipes if you need to both send data to and receive data
from another process.</p></li><li><p>The <span class="stt">Rio_readn</span> and <span class="stt">Rio_writen</span> functions from
<span class="stt">"csapp.c"</span> are helpful for avoiding the partial reads
and writes that are possible with <span class="stt">Read</span> and <span class="stt">Write</span>. The
functions have the same signatures as <span class="stt">Read</span> and <span class="stt">Write</span>,
but <span class="stt">Rio_readn</span> will only return less than <span class="stt">n</span> if it
encounters an end-of-file, and <span class="stt">Rio_writen</span> will write all
<span class="stt">n</span> bytes (unless there is an error, which will terminate
the program):</p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">ssize_t Rio_readn(int fd, void *usrbuf, size_t n);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">void Rio_writen(int fd, void *usrbuf, size_t n);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr></tbody></table></li><li><p>Use <span class="stt">Signal(SIGPIPE, SIG_IGN)</span> to avoid unwanted signals
when a pipe is closed by another process.</p></li><li><p>Start by just running <span class="stt">game_maker</span>, which involves adding
<span class="stt">Fork</span>. Instead of running a player, simulate good and bad
players by sending literal strings the <span class="stt">game_maker</span> process
and checking that you get the expected results back.</p></li><li><p>Next, make <span class="stt">game_maker</span> cooperate with a single player for a
single round.</p></li><li><p>Next, support multiple well-behaved players and multiple
rounds.</p></li><li><p>Next, support misbehaved players like <span class="stt">fumble_player</span>,
<span class="stt">garbled_player</span>, and <span class="stt">unreliable_player</span>.</p></li><li><p>Finally, implement Ctl-C handling. You’ll probably need
functions like <span class="stt">Signal</span> and <span class="stt">Sigprocmask</span>. Note that
<span class="stt">Setpgid</span> is one way of preventing a Ctl-C that is intended
for <span class="stt">run_tournament</span> from being sent to child processes of
<span class="stt">run_tournament</span>, since a terminal will send Ctl-C to a
process group. Also remember that relevant signals will need to
be blocked while a process is being created.</p></li><li><p>If your implementation includes a call to <span class="stt">sleep</span>, <span class="stt">Sleep</span>,
<span class="stt">pause</span>, or <span class="stt">Pause</span>, then you’re doing it wrong.</p></li></ul><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html" title="backward to &quot;Linking Assignment&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" title="up to &quot;Homework Assignments&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/malloc.html" title="forward to &quot;Malloc Assignment&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>