<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0048)https://pubweb.eng.utah.edu/~cs4400/linklab.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=0.8"><title>Linking Assignment</title><link rel="stylesheet" type="text/css" href="./Linking Assignment_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="./Linking Assignment_files/manual-style.css" title="default"><style type="text/css">
.tocset { background-color: hsl(87.5, 24%, 52.5%); }
</style><link rel="stylesheet" type="text/css" href="./Linking Assignment_files/manual-racket.css" title="default"><script type="text/javascript" src="./Linking Assignment_files/scribble-common.js"></script><script type="text/javascript" src="./Linking Assignment_files/manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a></td><td></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html" class="tocviewlink" data-pltdoc="x">CS 4400 – Computer Systems &nbsp; Fall 2018</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._.Schedule__subject_to_change_%29" class="tocviewlink" data-pltdoc="x">Schedule <span class="Smaller">[subject to change]</span></a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._staff%29" class="tocviewlink" data-pltdoc="x">Course Staff</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._desc%29" class="tocviewlink" data-pltdoc="x">Course Description</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._.Videos%29" class="tocviewlink" data-pltdoc="x">Videos</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._.No_.Videos%29" class="tocviewlink" data-pltdoc="x">No Videos</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" class="tocviewselflink" data-pltdoc="x">Homework Assignments</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a></td><td></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" class="tocviewlink" data-pltdoc="x">Homework Assignments</a></td></tr></tbody></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/bomb.html" class="tocviewlink" data-pltdoc="x">Bomb Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/performance.html" class="tocviewlink" data-pltdoc="x">Performance Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html" class="tocviewselflink" data-pltdoc="x">Linking Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/shell.html" class="tocviewlink" data-pltdoc="x">Shell Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/malloc.html" class="tocviewlink" data-pltdoc="x">Malloc Assignment</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/servlab.html" class="tocviewlink" data-pltdoc="x">Server Assignment</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a></td><td></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html" class="tocviewselflink" data-pltdoc="x">Linking Assignment</a></td></tr></tbody></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._.Starting_.Implementation%29" class="tocviewlink" data-pltdoc="x">Starting Implementation</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._assumptions%29" class="tocviewlink" data-pltdoc="x">Assumptions</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._linklab-evaluation%29" class="tocviewlink" data-pltdoc="x">Evaluation</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._decode%29" class="tocviewlink" data-pltdoc="x">Decoding Machine Code</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._.Tips%29" class="tocviewlink" data-pltdoc="x">Tips</a></td></tr><tr><td align="right"></td><td><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._linking-tests%29" class="tocviewlink" data-pltdoc="x">Test Cases and Test Harness</a></td></tr></tbody></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tbody><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._.Starting_.Implementation%29" class="tocsubseclink" data-pltdoc="x">Starting Implementation</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._assumptions%29" class="tocsubseclink" data-pltdoc="x">Assumptions</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._linklab-evaluation%29" class="tocsubseclink" data-pltdoc="x">Evaluation</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._decode%29" class="tocsubseclink" data-pltdoc="x">Decoding Machine Code</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._.Tips%29" class="tocsubseclink" data-pltdoc="x">Tips</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._linking-tests%29" class="tocsubseclink" data-pltdoc="x">Test Cases and Test Harness</a></td></tr></tbody></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/performance.html" title="backward to &quot;Performance Assignment&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" title="up to &quot;Homework Assignments&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/shell.html" title="forward to &quot;Shell Assignment&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div><h4><a name="(part._linklab)"></a>Linking Assignment</h4><p>Due: Thursday, October 25, 11:59pm</p><p>This assignment is about understanding how the ELF format supports
run-time linking for shared libraries on x86_64, including the way
that references to global variables and functions are implemented and
represented.<span class="refelem"><span class="refcolumn"><span class="refcontent">Less directly, this assignment is also about
manipulating pointers and numbers and moving between them. That
practice should help with assignments later in the semester, too.</span></span></span></p><p>Starting with <a href="https://pubweb.eng.utah.edu/~cs4400/linklab-handout.zip"><span class="stt">linklab-handout.zip</span></a>, your task is to implement <span class="stt">enforce</span>, which
copies an ELF-format shared library and</p><ul><li><p>identifies all global functions that are exported by the shared
library, where the functions may include calls to <span class="stt">open_it</span>
and <span class="stt">close_it</span>;</p></li><li><p>makes sure that a function balances any call to <span class="stt">open_it</span> with
a call to <span class="stt">close_it</span> before returning;</p></li><li><p>makes sure that a function does not access a global variable
whose name starts <span class="stt">protected_</span> except between an <span class="stt">open_it</span>
and <span class="stt">close_it</span> pair; and</p></li><li><p>replaces any of the following with an instruction to crash with
a trace/breakpoint interrupt:</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>You don’t have to know how to implement a
trace/breakpoint interrupt, since that’s covered by a helper
library that is included with the initial implementation.</p></blockquote></blockquote></blockquote><ul><li><p>a call to <span class="stt">open_it</span> after a call to <span class="stt">open_it</span> with
no <span class="stt">close_it</span> in between;</p></li><li><p>a call to <span class="stt">close_it</span> after a call to <span class="stt">close_it</span> with
no call to <span class="stt">open_it</span> in between;</p></li><li><p>a return after a call to <span class="stt">open_it</span> with no
<span class="stt">close_it</span> in between;</p></li><li><p>an access to a global variable whose name starts with
<span class="stt">protected_</span> where the access is not between
<span class="stt">open_it</span> and <span class="stt">close_it</span>.</p></li></ul></li></ul><p>The intent is that your <span class="stt">enforce</span> starts processing a function in
<span style="font-style: italic">closed</span> mode, switches from <span style="font-style: italic">closed</span> to <span style="font-style: italic">open</span> when it sees
<span class="stt">open_it</span> (or replaces with a crash if the current mode is already
<span style="font-style: italic">open</span>), and switches from <span style="font-style: italic">open</span> mode to <span style="font-style: italic">closed</span> mode when it
sees <span class="stt">close_it</span> (or replaces with a crash if the current mode is
<span style="font-style: italic">closed</span>). An access to a <span class="stt">protected_</span> variable is replaced with
a crash if the current mode is <span style="font-style: italic">closed</span>, and a return is replaced
with a crash if the current mode is <span style="font-style: italic">open</span>.</p><p>For example, given a shared library that is the compiled form of</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int other_v1 = 4;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int other_v2 = 5;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int protected_v3 = 3;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int protected_v4 = 4;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int f(int sel) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if (sel &gt; 0) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return protected_v4; /* oops - access not between open &amp; close */</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">} else if (sel == 0) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">int v;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">open_it();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">v = protected_v3;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">close_it();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return v;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">} else {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">open_it();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">if (sel &lt; -1) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">close_it();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return other_v1;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">} else</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return other_v2;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">/* oops - return without close */</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></tbody></table><p></p><p>then the shared library has the following initial behaviors:</p><ul><li><p><span class="stt">f(1)</span> will return 4 through a bad access of <span class="stt">protected_v4</span>
that is not between <span class="stt">open_it</span> and <span class="stt">close_it</span>.</p></li><li><p><span class="stt">f(0)</span> will return 3 by accessing <span class="stt">protected_v3</span>, which is
a good access since it’s between <span class="stt">open_it</span> and <span class="stt">close_it</span>.</p></li><li><p><span class="stt">f(-1)</span> will call <span class="stt">open_it</span> without balancing the call,
so there’s a bad return of the value of <span class="stt">other_v2</span>.</p></li><li><p><span class="stt">f(-2)</span> will call <span class="stt">open_it</span> and a balancing
<span class="stt">close_it</span>, so there’s a good return of the value of
<span class="stt">other_v1</span>.</p></li></ul><p>A copy of the shared library produced by <span class="stt">enforce</span>, however, will
have the following behaviors:</p><ul><li><p><span class="stt">f(1)</span> will crash, since the bad access is replaced by a
crash.</p></li><li><p><span class="stt">f(0)</span> will return 3 by accessing <span class="stt">protected_v3</span>, as
before.</p></li><li><p><span class="stt">f(-1)</span> will crash, since the bad return is replaced by
a crash.</p></li><li><p><span class="stt">f(-2)</span> will return of the value of <span class="stt">other_v1</span>, since the
call to <span class="stt">open_it</span> is balanced with a call to <span class="stt">close_it</span>.</p></li></ul><p>You can find additional and simpler examples in
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/ex0.c">ex0.c</a>"</span>,
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/ex1.c">ex1.c</a>"</span>,
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/ex2.c">ex2.c</a>"</span>,
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/ex3.c">ex3.c</a>"</span>, and
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/ex4.c">ex4.c</a>"</span>,
which are included with the starting code.</p><h5><a name="(part._.Starting_.Implementation)"></a>Starting Implementation</h5><p>The starting code
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/enforce.c">enforce.c</a>"</span> handles
copying a shared-library file to a destination file based on the
command-line arguments. The <span class="stt">enforce</span> function—<wbr>which doesn’t do
anything in the starting code—<wbr>receives a pointer to the in-memory
copy of the destination file. Your job is to fill in the
implementation of <span class="stt">enforce</span> so that it changes the destination file.</p><p>To determine function and variable information, your <span class="stt">enforce</span>
function will read the destination ELF file as it exists in memory. To
replace certain variable accesses and function calls with a crash,
your <span class="stt">enforce</span> function will modify the in-memory copy of the ELF
file. Through the magic of <span class="stt">mmap</span> (which we will cover later in
the semester), those in-memory changes will be reflected in the
destination file.</p><p>A key step in the implementation of <span class="stt">enforce</span> is to decode the
machine code that implements a function. Since decoding x86_64 machine
code is tedious, the starting implementation includes
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/decode.c">decode.c</a>"</span> and
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/decode.h">decode.h</a>"</span>, where
<span class="stt">"decode.c"</span> implements a <span class="stt">decode</span> function. The <span class="stt">decode</span>
function is sufficient for functions in the shared libraries that we
will use to test your implementation. In addition, <span class="stt">"decode.c"</span>
provides <span class="stt">replace_with_crash</span>, which can replace an instruction
with one to provoke a crash through a trace/breakpoint interrupt. See
<a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._decode%29" data-pltdoc="x">Decoding Machine Code</a> for more information on using <span class="stt">decode</span> and
<span class="stt">replace_with_crash</span>.</p><p>Your submitted solution will take the form of a single C file,
<span class="stt">"enforce.c"</span>, which must be implemented in ANSI C with GNU
extensions. You must not modify <span class="stt">"decode.c"</span> or
<span class="stt">"decode.h"</span>, since you submit only your <span class="stt">"enforce.c"</span>
file. We’ll compile and link <span class="stt">enforce.c</span> in the same way as in
<span class="stt">"<a href="https://pubweb.eng.utah.edu/~cs4400/Makefile">Makefile</a>"</span>, so it
must be self-contained other than its uses of <span class="stt">"decode.h"</span>,
<span class="stt">"decode.c"</span>, <span class="stt">"elf.h"</span>, limited Unix headers and
libraries for <span class="stt">open</span> and <span class="stt">mmap</span>, and ANSI C headers and
libraries.</p><h5><a name="(part._assumptions)"></a>Assumptions</h5><p>To simplify your task, you can make several assumptions:</p><ul><li><p>Your <span class="stt">enforce</span> need only recognize and adjust functions that
are registered in the dynamic-symbol table (i.e., the
<span class="stt">.dynsym</span> section) as a function type with a non-zero size.</p></li><li><p>Your <span class="stt">enforce</span> can assume the usual strategies for implementing
relocatable variables and functions in Linux. In particular,
accessing a variable will go through a memory location that is
listed in the <span class="stt">.rela.dyn</span> section, and jumping to an
imported or exported function will go through the global offset
table as described by a <span class="stt">rela.plt</span> section.</p></li><li><p>Your <span class="stt">enforce</span> can assume that all references to functions
are function calls, and no references to variables are function
calls.</p></li><li><p>Your <span class="stt">enforce</span> need only handle functions where the
implementation is supported by <span class="stt">decode</span>. The <span class="stt">decode</span>
function recognizes variants of <span class="stt">mov</span>, <span class="stt">ret</span>, <span class="stt">cmp</span>,
<span class="stt">test</span>, <span class="stt">jmp</span>, <span class="stt">j</span><span style="font-style: italic">cc</span>, and <span class="stt">call</span>
instructions, among others.</p></li><li><p>Your <span class="stt">enforce</span> need only handle calls to the functions
<span class="stt">open_it</span> and <span class="stt">close_it</span>. No other functions will be
called.</p></li><li><p>Your <span class="stt">enforce</span> can assume that the functions in a shared
library contain no loops. Furthermore, if a function branches,
then you can treat branch as reaching distinct instructions and eventually
returning independently (i.e., there are no branch joins that matter). Your
<span class="stt">enforce</span> can also assume that a function contains less
than 20 conditional branches. These constraints simplify the
traversal of a function’s machine code.</p></li></ul><h5><a name="(part._linklab-evaluation)"></a>Evaluation</h5><p>To earn points, your implementation must correctly install crashes in
the form of a trace/breakpoint interrupt.</p><ul><li><p>You can earn up to 80 points by handling only functions that
contain no branches and that do not access global variables
that start <span class="stt">protected_</span>.</p></li><li><p>You can earn up to 90 points by detecting bad references to
global variables that start <span class="stt">protected_</span>, replacing the bad
references with a crash, but still not handling functions with
branches.</p></li><li><p>You can earn full credit only by handling functions branches,
still replacing bad returns, <span class="stt">open_it</span> calls, <span class="stt">close_it</span>
calls, and references with a trace/breakpoint interrupt.</p></li></ul><p>When grading, we will infer a level of completion based on your
program’s behavior on the tests that are included with <a href="https://pubweb.eng.utah.edu/~cs4400/linklab-handout.zip"><span class="stt">linklab-handout.zip</span></a>. We
will then scale your grade for each level based on the number of our
test cases that pass.</p><p>Your <span class="stt">enforce</span> can print out any information that you find useful.
Our tests will look only at the shared library produced by
<span class="stt">enforce</span>.</p><h5><a name="(part._decode)"></a>Decoding Machine Code</h5><p>The <span class="stt">decode</span> function provided by <span class="stt">"decode.c"</span> has the
prototype</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">void decode(instruction_t *ins, code_t *code_ptr, Elf64_Addr code_addr);</span></p></td></tr></tbody></table><p></p><p>where <span class="stt">code_ptr</span> refers to the machine code to decode, and
<span class="stt">code_addr</span> is the address where that code will reside at run time.
(The <span class="stt">code_addr</span> must be provided so that <span class="stt">decode</span> can tell
the destination of relative references in the machine code.)
The type <span class="stt">code_t</span> is an alias for <span class="stt">unsigned char</span>. Use
<span class="stt">code_t*</span> for a pointer to machine code, so that pointer arithmetic works
in terms of bytes, since <span class="stt">decode</span> reports an instruction length in
bytes.</p><p>The <span class="stt">ins</span> argument receives the result of decoding one instruction,
so pass the address of a locally declared <span class="stt">instruction_t</span> to
<span class="stt">decode</span>. The <span class="stt">instruction_t</span> struct type has three fields:
<span class="stt">op</span>, <span class="stt">length</span>, and <span class="stt">addr</span>. The <span class="stt">decode</span> function always
fills in <span class="stt">ins-&gt;op</span> and <span class="stt">ins-&gt;length</span>, and it fills in
<span class="stt">ins-&gt;addr</span> for some values of <span class="stt">ins-&gt;op</span>.</p><p>The possible values for <span class="stt">op</span> are (as defined in <span class="stt">"decode.h"</span>):</p><ul><li><p><span class="stt">MOV_ADDR_TO_REG_OP</span> —<wbr> The instruction moves a constant
address into a register, possibly to access a global variable.
The <span class="stt">ins-&gt;addr</span> field is set to the run-time
address, and it’s a reference to a global variable if that
address corresponds to a variable that is registered as a
dynamic symbol.</p></li><li><p><span class="stt">JMP_TO_ADDR_OP</span> —<wbr> The instruction jumps to a constant
address, possibly as a tail call to an global function. The
<span class="stt">ins-&gt;addr</span> field is set to the destination of
the jump as a run-time address, and it’s a call to a global
function if that address corresponds to a function that is
registered as a dynamic symbol. The instruction after the jump
need not be considered, unless it is reached through some other
jump.</p></li><li><p><span class="stt">MAYBE_JMP_TO_ADDR_OP</span> —<wbr> The instruction conditionally
jumps to a constant address, most likely due to an <span class="stt">if</span> in
the original program. The <span class="stt">ins-&gt;addr</span> field
is set to the destination of the jump as a run-time address.
This jump is never a call to a function, but the code at the
target of the jump may go on to call a function or access a
variable. If the jump is not taken, the immediately following
instructions might access a variable or call a function.</p></li><li><p><span class="stt">CALL_OP</span> —<wbr> The instruction calls a function. The
<span class="stt">ins-&gt;addr</span> field is set to the destination of the
call as a run-time address, and it’s a call to a global
function if that address corresponds to a function that is
registered as a dynamic symbol.</p></li><li><p><span class="stt">RET_OP</span> —<wbr> The instruction returns from the current
function, so the instructions after the return need not be
considered, unless they are reached through an earlier jump.
The <span class="stt">ins-&gt;addr</span> field is not set.</p></li><li><p><span class="stt">OTHER_OP</span> —<wbr> The instruction is a move, arithmetic
operation, or comparison operation that involves only registers
and non-address constants. Your <span class="stt">enforce</span> can assume that
these operations do not somehow synthesize the address of a
global variable or function, so it can effectively ignore them.
The <span class="stt">ins-&gt;addr</span> field is not set.</p></li></ul><p>For all operations, the <span class="stt">ins-&gt;length</span> field is set to the length of the
machine-code instruction in bytes, so <span class="stt">code_ptr + ins-&gt;length</span> is a
pointer to the next instruction, if any. The
<a href="https://pubweb.eng.utah.edu/~cs4400/linklab.html#%28part._assumptions%29" data-pltdoc="x">assumptions</a> allowed for <span class="stt">enforce</span> means
that both branches of a conditional (i.e., the target of a
<span class="stt">MAYBE_JMP_TO_ADDR_OP</span> instruction and the immediately following
instruction) can be explored by using a recursive call to an
instruction-traversal procedure for one or both of the branches.
<span class="refelem"><span class="refcolumn"><span class="refcontent">Don’t try to use a loop instead of recursion to handle
jumps. Branches generate a tree shape instead of a sequence shape, so
recursion is the right tool (even in C, if the tree is shallow). A
loop is the right choice for traversing instructions up to a branch,
though.</span></span></span></p><p>If <span class="stt">decode</span> does not recognize the content at <span class="stt">code_ptr</span> as a
machine-code instruction, it reports an error and exits. We will use
test inputs where public functions conform to the constraints of
<span class="stt">decode</span>, so you do not need to handle machine code that
<span class="stt">decode</span> does not recognize (when used properly).</p><p>The <span class="stt">"decode.c"</span> library also provides <span class="stt">replace_with_crash</span>:</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">void replace_with_crash(code_t *code_ptr, instruction_t *ins);</span></p></td></tr></tbody></table><p></p><p>Pass <span class="stt">code_ptr</span> for an instruction that you want to replace
with a trace/breakpoint interrupt. Also pass <span class="stt">ins</span> as filled with
information about the existing instruction, so that
<span class="stt">replace_with_crash</span> knows how many bytes to replace (filling with
“no-op” instruction bytes as necessary to fully replace the original
instruction).</p><h5><a name="(part._.Tips)"></a>Tips</h5><p>The information about ELF that you need to complete this assignment is
mostly covered by <a href="https://pubweb.eng.utah.edu/~cs4400/elf.html" data-pltdoc="x">Videos: ELF</a>. The <a href="https://pubweb.eng.utah.edu/~cs4400/elf-map.pdf">map
slides</a> should be helpful to find your way through a file; see also
<a href="https://www.youtube.com/watch?v=6cq9T2zvuz4">a video explaining
the map</a>. More generally, you can use
<span class="stt">"/usr/include/elf.h"</span> as a reference to find relevant
structures, fields, and macros. You might also consult any number of
other ELF references on the web.</p><p>Use <span class="stt">readelf</span> to get a human-readable form of the content of an ELF
file to get an idea of what your program should find. Use <span class="stt">objdump
-d</span> to disassemble functions to get an idea of what your program will
recognize using <span class="stt">decode</span> and to compare your output shared library
to the input shared library.</p><p>All of the information that you need from the ELF file can be found
via section headers and section content, so you will not need to use
program headers. You’ll need to consult the <span class="stt">.dynsym</span>,
<span class="stt">.dynstr</span>, <span class="stt">.rela.dyn</span>, <span class="stt">.plt</span>, and <span class="stt">.rela.plt</span> sections,
at least.</p><p>When working with ELF content, you have to keep track of which references
are in terms of file offsets and which are in terms of (tentative)
run-time addresses where the library will eventually run. When working
with ELF content that is <span class="stt">mmap</span>ped into memory (as in the starting
<span class="stt">"enforce.c"</span>), then you have one more way of referencing
things: a pointer in memory at present. Be careful to keep in mind
which kind of reference you have at any time. Again, the
<a href="https://pubweb.eng.utah.edu/~cs4400/elf-map.pdf">maps</a> should help.</p><p>Don’t confuse “symbol” with “string,” and keep in mind that they
are referenced in different ways. Symbols are referenced by an index
that corresponds to the symbol’s position in an array of symbols.
Strings are referenced by an offset in bytes within the relevant
string section. Every symbol has a string for its name.</p><p>Take small steps. Start out by printing the symbol index for every
function that is provided by the shared library. Then, print the name
instead of the symbol index. Then, print the address where each
function’s implementation is found, and so on.</p><p>Avoid parsing ELF information into your own set of data structures. An
ELF file in memory can be viewed as a data structure already, based on
the types that <span class="stt">"elf.h"</span> defines. Following different kinds of
references is not always trivial, but it’s not difficult, and you can
write little functions to make access more convenient and readable.
The task and examples are small enough that there’s no need for extra
tables or data structures to speed up searches.</p><p>As a lower bound, a complete solution can fit in about 250 lines of C
code, including the 120 lines in the provided in the starting
<span class="stt">"enforce.c"</span>. Depending on whitespace (fine), comments (good),
error checking (commendable), and duplicated code instead abstracting
into a function (bad), many solutions will be the range of 300-400
lines.</p><h5><a name="(part._linking-tests)"></a>Test Cases and Test Harness</h5><p>The archive <a href="https://pubweb.eng.utah.edu/~cs4400/linklab-handout.zip"><span class="stt">linklab-handout.zip</span></a> provides a <span class="stt">"Makefile"</span> where the
default target builds</p><ul><li><p>your <span class="stt">enforce</span> program from <span class="stt">"enforce.c"</span>;</p></li><li><p>a <span class="stt">call</span> program to try a function from a shared library; and</p></li><li><p>shared libraries <span class="stt">"ex0.so"</span> through <span class="stt">"ex4.so"</span> from the sources
<span class="stt">"ex0.c"</span> through <span class="stt">"ex4.c"</span>.</p></li></ul><p>For example, after running <span class="stt">make</span> with the initial files, you can
check that calling <span class="stt">"ex0.so"</span>’s <span class="stt">always_ok</span> with the argument
<span class="stt">1</span> produces the result <span class="stt">1</span> and <span class="stt">never_ok</span> with the argument <span class="stt">1</span>
produces the result <span class="stt">3</span>:</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">$ ./call ex0.so always_ok 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">$ ./call ex0.so never_ok 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">3</span></p></td></tr></tbody></table><p></p><p>After you have completed <span class="stt">enforce</span> for enforcing paired
<span class="stt">open_it</span> and <span class="stt">close_it</span>, then</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">$ ./enforce ex0.so dest.so</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">$ ./call dest.so always_ok 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">$ ./call dest.so never_ok 1</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Trace/BPT trap</span></p></td></tr></tbody></table><p></p><p>Alternatively, you can use <span class="stt">objdump -d dest.so</span> and compare to
<span class="stt">objdump -d ex0.so</span> to check whether your <span class="stt">enforce</span> has replaced
the return in <span class="stt">never_ok</span> with an <span class="stt">int3</span> instruction that
triggers a trace/breakpoint interrupt.</p><p>The <span class="stt">test</span> makefile target runs your <span class="stt">enforce</span> on the
<span class="stt">"ex<span style="font-style: italic">n</span>.so"</span> shared libraries (overwriting
<span class="stt">"dest.so"</span> for each attempt) and checks that the result
behaves as predicted at the top of the <span class="stt">"ex<span style="font-style: italic">n</span>.c"</span>
source. You can use The <span class="stt">make test80</span> to run only tests for the
80-point level of completeness, which is <span class="stt">"ex0.so"</span>. You can
<span class="stt">make test90</span> to run only tests for the 90-point level of
completeness, which is <span class="stt">"ex0.so"</span> and <span class="stt">"ex1.so"</span>.</p><p>For grading, we will run your program on additional shared-library
files. We may also compile your program with different optimization or
debugging options; as always, your program must build with <span class="stt">gcc</span> on
CADE machines with no language-adjusting command-line flags.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/performance.html" title="backward to &quot;Performance Assignment&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/index.html#%28part._hw%29" title="up to &quot;Homework Assignments&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://pubweb.eng.utah.edu/~cs4400/shell.html" title="forward to &quot;Shell Assignment&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>